<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Exploration Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { margin:0; height:100%; background:#111; font-family:-apple-system,BlinkMacSystemFont,sans-serif; }
    #map { height:80%; }
    #ui { height:20%; padding:10px 14px; background:#1a1a1a; color:#ddd; box-sizing:border-box; }
    .row { margin-bottom:8px; }
    select, input[type="range"], button {
      width:100%; padding:10px; background:#111; color:#ddd; border:1px solid #333;
      border-radius:8px; font-size:14px; box-sizing:border-box;
    }
    input[type="range"] { width:96%; margin:0 auto; display:block; height:28px; }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance:none; width:28px; height:28px; border-radius:50%; background:#fff; border:none;
    }
    #dateLabel { font-size:14px; color:#fff; font-weight:bold; }
    #timeIcon { margin-right:6px; font-size:16px; }
    #status { font-size:12px; color:#888; }
    .row.flex { display:flex; gap:8px; align-items:center; overflow:hidden; }
    .row.flex > * { min-width:0; }
    button#playBtn { flex:0 0 120px; }
    button#stopBtn { flex:0 0 80px; opacity:0.95; }
    select#dateSelect { text-overflow:ellipsis; overflow:hidden; white-space:nowrap; }
    .timeRow { display:flex; align-items:center; gap:6px; }

    .eventIcon {
      font-size: 22px;
      line-height: 22px;
      transform: translateY(-3px);
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.7));
      text-shadow:
        -1px -1px 0 rgba(0,0,0,0.6),
        1px -1px 0 rgba(0,0,0,0.6),
        -1px  1px 0 rgba(0,0,0,0.6),
        1px  1px 0 rgba(0,0,0,0.6);
      opacity: 0.95;
    }
    .evtPopup {
      font-size:12px; color:#eee; background:rgba(20,20,20,0.92);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px; padding:8px 10px; max-width:220px;
      animation:fadeIn 0.22s ease-out forwards;
    }
    @keyframes fadeIn { from { opacity:0; transform:translateY(4px);} to { opacity:1; transform:translateY(0);} }
    .leaflet-popup-content-wrapper { background:transparent; box-shadow:none; }
    .leaflet-popup-tip { background:rgba(20,20,20,0.92); }
  </style>
</head>
<body>

<div id="map"></div>

<div id="ui">
  <div class="row">
    <select id="dateSelect" disabled>
      <option value="">æ•£æ­©ã‚’é¸ã¶</option>
    </select>
  </div>

  <div class="row flex">
    <button id="playBtn" disabled>æ•£æ­©ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button id="stopBtn" disabled>åœæ­¢</button>
  </div>

  <div class="row timeRow">
    <span id="timeIcon"></span>
    <span id="dateLabel">èª­ã¿è¾¼ã¿ä¸­â€¦</span>
    <span id="progressLabel" style="font-size:12px; color:#bbb; margin-left:8px;"></span>
  </div>

  <div class="row">
    <input type="range" id="timeSlider" min="0" max="0" value="0" disabled />
  </div>

  <div id="status">ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰ãƒ­ã‚°ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™</div>
</div>

<script>
  const GAS_URL = "https://script.google.com/macros/s/AKfycbx36tsy3sptr2-gaJnHr__Gq6VWxQ6cunpRMvNISNKjS-2NHorz0qYbKJJV8P0VDdBC/exec";
  const LOG_ID_FOR_MEMOS = "log_test"; // æš«å®š

  const map = L.map('map', { preferCanvas: true }).setView([35.7216, 140.1555], 15);
  // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap' }).addTo(map);
  L.tileLayer(
    'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
    { attribution: 'Â© OpenStreetMap Â© CARTO' }
  ).addTo(map);
  
  let allPoints = [];
  let timeBuckets = [];
  let footprintMarkers = [];
  let eventMarkers = [];

  let logs = [];
  let selectedLogId = "";

  let isLoading = false;

  let autoPanned = false;

  let playTimer = null;
  let isPlaying = false;

  // ã‚¤ãƒ™ãƒ³ãƒˆ
  let currentEvents = [];
  let lastAutoPopupAt = 0;

  // åŒä¸€bucketã§è¤‡æ•°ãƒ¡ãƒ¢ã‚’é †ã«å‡ºã™ãŸã‚ã®ç°¡æ˜“ã‚­ãƒ¥ãƒ¼
  let popupQueue = [];
  let pumpingQueue = false;

  const slider = document.getElementById('timeSlider');
  const label  = document.getElementById('dateLabel');
  const progressLabel = document.getElementById('progressLabel');
  const timeIcon = document.getElementById('timeIcon');
  const status = document.getElementById('status');
  const dateSelect = document.getElementById('dateSelect');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');

  // ===== ãƒ¡ãƒ¢ç”¨ã‚¢ã‚¤ã‚³ãƒ³å®šç¾© =====
  const MEMO_ICON_DEFS = {
    event:  { html: 'ğŸ“', className: 'icon-event' },
    food:   { html: 'ğŸ½ï¸', className: 'icon-food' },
    notice: { html: 'ğŸ’¡', className: 'icon-notice' },
    rest:   { html: 'â˜•', className: 'icon-rest' }
  };
  
  function createMemoIcon(iconType) {
    const def = MEMO_ICON_DEFS[iconType];
    if (!def) return null;

    return L.divIcon({
      className: `eventIcon ${def.className}`,
      html: def.html,
      iconSize: [18, 18],
      iconAnchor: [9, 9]
    });
  }

  function clearLayers(arr) {
    arr.forEach(l => map.removeLayer(l));
    arr.length = 0;
  }

  function makeTimeKey(iso, unit) {
    const d = new Date(iso);
    if (unit === 'minute') d.setSeconds(0, 0);
    if (unit === 'hour')   d.setMinutes(0, 0, 0);
    if (unit === 'day' || unit === 'day_sum') d.setHours(0, 0, 0, 0);
    if (unit === 'month' || unit === 'month_sum') { d.setDate(1); d.setHours(0, 0, 0, 0); }
    return d.toISOString();
  }

  function buildBuckets(unit, points = allPoints) {
    const mapBuckets = new Map();
    points.forEach(p => {
      const key = makeTimeKey(p.time, unit);
      if (!mapBuckets.has(key)) mapBuckets.set(key, []);
      mapBuckets.get(key).push(p);
    });
    return Array.from(mapBuckets.entries()).sort((a, b) => a[0].localeCompare(b[0]));
  }

  const footprintSvg =
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">' +
    '<circle cx="6"  cy="7"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="10" cy="5"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="14" cy="5"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="18" cy="7"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<ellipse cx="12" cy="14" rx="5.8" ry="4.6" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="6"  cy="7"  r="2" fill="#444"/>' +
    '<circle cx="10" cy="5"  r="2" fill="#444"/>' +
    '<circle cx="14" cy="5"  r="2" fill="#444"/>' +
    '<circle cx="18" cy="7"  r="2" fill="#444"/>' +
    '<ellipse cx="12" cy="14" rx="5" ry="4" fill="#444"/>' +
  '</svg>';

  function distance(a, b) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const s =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) *
      Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function areaRadiusByZoom(zoom) {
    if (zoom >= 14) return 400;
    if (zoom >= 13) return 550;
    if (zoom >= 12) return 800;
    if (zoom >= 11) return 1200;
    if (zoom >= 10) return 1600;
    if (zoom >= 9)  return 2200;
    return 3000;
  }

  // function timeIconFromHour(h) {
  //   if (h >= 5 && h < 9)  return "ğŸŒ…";
  //   if (h >= 9 && h < 16) return "â˜€ï¸";
  //   if (h >= 16 && h < 19) return "ğŸŒ†";
  //   return "ğŸŒ™";
  // }

  function escapeHtml(str) {
    return String(str)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function showEventPopup(latlng, content, autoCloseMs = 0) {
    const now = Date.now();
    if (autoCloseMs > 0 && now - lastAutoPopupAt < 250) return;
    lastAutoPopupAt = now;

    const popup = L.popup({ closeButton: false, autoClose: true, closeOnClick: true })
      .setLatLng(latlng)
      .setContent(`<div class="evtPopup">${escapeHtml(content)}</div>`)
      .openOn(map);

    if (autoCloseMs > 0) {
      setTimeout(() => {
        try { map.closePopup(popup); } catch(e) {}
      }, autoCloseMs);
    }
  }

  async function loadMemosTemporary() {
    try {
      const url = `${GAS_URL}?type=memos&logId=${encodeURIComponent(LOG_ID_FOR_MEMOS)}`;
      const res = await fetch(url);
      if (!res.ok) return [];
      const memos = await res.json();

      if (!Array.isArray(memos) || memos.length === 0) {
        return [];
      }

      return memos.map(m => {
        const ceil = ceilToNextMinute(m.time);
        return {
          ...m,
          time: ceil.toISOString()   // â† ã“ã®æ™‚ç‚¹ã§ time ã‚’ç¢ºå®š
        };
      });
      
    } catch (e) {
      return [];
    }
  }

  function findNearestPointIndexByTime(points, isoTime) {
    const target = new Date(isoTime).getTime();
    if (!points.length) return 0;

    let lo = 0;
    let hi = points.length - 1;

    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const t = new Date(points[mid].time).getTime();
      if (t === target) return mid;
      if (t < target) lo = mid + 1;
      else hi = mid - 1;
    }

    if (lo <= 0) return 0;
    if (lo >= points.length) return points.length - 1;

    const tLo = Math.abs(new Date(points[lo].time).getTime() - target);
    const tHi = Math.abs(new Date(points[lo - 1].time).getTime() - target);
    return (tHi <= tLo) ? (lo - 1) : lo;
  }

  function ceilToNextMinute(iso) {
    const d = new Date(iso);
    if (d.getSeconds() === 0 && d.getMilliseconds() === 0) return d;
    d.setMinutes(d.getMinutes() + 1);
    d.setSeconds(0, 0);
    return d;
  }

  function formatElapsedTime(elapsedMin) {
    if (elapsedMin < 60) {
      return `${elapsedMin}åˆ†`;
    }
    const h = Math.floor(elapsedMin / 60);
    const m = elapsedMin % 60;
    return `${h}æ™‚é–“${String(m).padStart(2, '0')}åˆ†`;
  }

  function formatLabel(dateIso, unit) {
    const d = new Date(dateIso);
      if (unit === 'minute') {
    // ç§’ãªã—
    return d.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
    if (unit === "day" || unit === "day_sum") return d.toLocaleDateString();
    if (unit === "month" || unit === "month_sum") return `${d.getFullYear()}å¹´${d.getMonth() + 1}æœˆ`;
    return d.toLocaleString();
  }

  function stopPlayback() {
    if (playTimer) { clearInterval(playTimer); playTimer = null; }
    isPlaying = false;
  }

  function startPlayback() {
    if (isLoading) return;
    const unit = 'minute';
    if (!(unit === 'minute' && selectedLogId)) return;
    if (playTimer) return;

    isPlaying = true;
    stopBtn.textContent = "åœæ­¢";

    const stepMs = 1800;
    playTimer = setInterval(() => {
      const v = Number(slider.value);
      const max = Number(slider.max);
      if (v >= max) { stopPlayback(); return; }
      autoPanned = false;
      slider.value = String(v + 1);
      render(Number(slider.value));
    }, stepMs);
  }

  function restartPlaybackFromBeginning() {
    if (isLoading) return;
    stopPlayback();
    isPlaying = true;
    slider.value = "0";
    autoPanned = false;
    currentEvents.forEach(e => {e.state = 'hidden';});
    popupQueue = [];
    pumpingQueue = false;
    render(0);
    startPlayback();
  }

  function pumpPopupQueue() {
    if (pumpingQueue) return;
    pumpingQueue = true;

    const tick = () => {
      if (!popupQueue.length) { pumpingQueue = false; return; }
      const item = popupQueue.shift();
      showEventPopup(item.latlng, item.content, 2200);
      setTimeout(tick, 550);
    };
    tick();
  }

function render2(index) {
  clearLayers(footprintMarkers);
  clearLayers(eventMarkers);

  const unit = 'minute';
  const isMinuteMode = (unit === 'minute' && selectedLogId);
  const isPlayback = isMinuteMode && isPlaying;

  const log = logs.find(l => l.id === selectedLogId);
  if (!log || !timeBuckets[index]) return;

  // ======================
  // è¡¨ç¤ºæ™‚åˆ»ï¼ˆåˆ†ä¸¸ã‚æ¸ˆã¿ï¼‰
  // ======================
  const currLabelMs = new Date(timeBuckets[index][0]).getTime();

  const prevIndex =
    (typeof render._prevIndex === 'number') ? render._prevIndex : index;

  const prevLabelMs =
    timeBuckets[prevIndex]
      ? new Date(timeBuckets[prevIndex][0]).getTime()
      : currLabelMs;

  // â˜… å‰å›ã‚³ãƒã¨ã®å·®åˆ†ï¼ˆåˆ†ï¼‰
  const deltaMin = Math.max(
    0,
    Math.round((currLabelMs - prevLabelMs) / 60000)
  );

  // ======================
  // çµŒéæ™‚é–“ï¼ˆindex åŸºæº–ã§æ¯å›å†è¨ˆç®—ï¼‰
  // ======================
  let elapsedMin = 0;
  for (let i = 1; i <= index; i++) {
    const a = new Date(timeBuckets[i - 1][0]).getTime();
    const b = new Date(timeBuckets[i][0]).getTime();
    elapsedMin += Math.max(0, Math.round((b - a) / 60000));
  }

  // ======================
  // cutoffMs
  // ======================
  let cutoffMs = currLabelMs;
  if (timeBuckets[index + 1]) {
    cutoffMs = new Date(timeBuckets[index + 1][0]).getTime() - 1;
  } else {
    cutoffMs = currLabelMs + 60 * 1000 - 1;
  }

  // ======================
  // è¶³è·¡æç”»
  // ======================
  const zoom = map.getZoom();
  const isRouteScale = zoom >= 14;
  const FOOTPRINT_INTERVAL = 60 * 1000;
  const THIN_BY_DISTANCE = areaRadiusByZoom(zoom);

  const allVisiblePoints = log.points.filter(p => {
    return new Date(p.time).getTime() <= cutoffMs;
  });

  const placed = [];
  let lastPlacedTime = null;
  let lastPlacedLatLng = null;

  allVisiblePoints.forEach(p => {
    const t = new Date(p.time).getTime();

    if (isRouteScale) {
      if (lastPlacedTime && t - lastPlacedTime < FOOTPRINT_INTERVAL) return;
      lastPlacedTime = t;
    }

    const latlng = { lat: p.lat, lng: p.lng };

    if (lastPlacedLatLng) {
      const d = distance(lastPlacedLatLng, latlng);
      if (!isRouteScale && d < THIN_BY_DISTANCE) return;
      if (isRouteScale && d < 8) return;
    }

    lastPlacedLatLng = latlng;
    placed.push(latlng);
  });

  const baseIcon = L.icon({
    iconUrl: 'data:image/svg+xml;base64,' + btoa(footprintSvg),
    iconSize: [18, 18],
    iconAnchor: [9, 9]
  });

  placed.forEach((p, idx) => {
    let opacity = 1.0;
    if (isPlayback) {
      const d = placed.length - 1 - idx;
      if (d === 0) opacity = 1.0;
      else if (d === 1) opacity = 0.65;
      else if (d === 2) opacity = 0.4;
      else opacity = 0.25;
    }

    footprintMarkers.push(
      L.marker([p.lat, p.lng], {
        icon: baseIcon,
        interactive: false,
        opacity
      }).addTo(map)
    );
  });

  // ======================
  // ãƒ©ãƒ™ãƒ«æ›´æ–°
  // ======================
  label.textContent = formatLabel(timeBuckets[index][0], unit);

  // ======================
  // è·é›¢è¨ˆç®—
  // ======================
  let dist = 0;
  let last = log.points[0];

  for (let i = 1; i < log.points.length; i++) {
    const p = log.points[i];
    const t = new Date(p.time).getTime();
    if (t > cutoffMs) break;
    dist += distance(last, p);
    last = p;
  }

  const km = (dist / 1000).toFixed(2);

  // ======================
  // çµŒéæ™‚é–“è¡¨ç¤ºï¼ˆâ˜…æ™‚é–“éƒ¨åˆ†ã®ã¿å¼·èª¿ï¼‰
  // ======================
  const timeText = formatElapsedTime(elapsedMin);

  // HTML ã‚’å…ˆã«çµ„ã¿ç«‹ã¦
  progressLabel.innerHTML =
    `ï½œï¼‹<span id="elapsedSpan">${timeText}</span> ï½œ ${km}km`;

  const elapsedSpan = progressLabel.querySelector('#elapsedSpan');

  // åˆæœŸçŠ¶æ…‹
  elapsedSpan.style.transition = 'none';
  elapsedSpan.style.fontWeight = '400';
  elapsedSpan.style.transform = 'scale(1)';
  elapsedSpan.style.opacity = '0.8';

  // â˜… 5åˆ†ä»¥ä¸Šï¼šå¼±å¼·èª¿
  if (deltaMin >= 5) {
    elapsedSpan.style.fontWeight = '600';
    elapsedSpan.style.opacity = '0.9';
    elapsedSpan.style.transform = 'scale(1.08)';
    elapsedSpan.style.transition =
      'transform 0.18s ease-out, opacity 0.25s ease-out';
  }

  // â˜… 30åˆ†ä»¥ä¸Šï¼šå¼·å¼·èª¿
  if (deltaMin >= 30) {
    elapsedSpan.style.fontWeight = '700';
    elapsedSpan.style.opacity = '1.0';
    elapsedSpan.style.transform = 'scale(1.18)';
  }

  // æˆ»ã—
  if (deltaMin >= 5) {
    requestAnimationFrame(() => {
      setTimeout(() => {
        elapsedSpan.style.transform = 'scale(1)';
        elapsedSpan.style.opacity = '0.85';
        elapsedSpan.style.fontWeight = '400';
      }, 220);
    });
  }

  // ======================
  // è‡ªå‹•ãƒ‘ãƒ³
  // ======================
  const lastPlaced = placed.length ? placed[placed.length - 1] : null;
  if (lastPlaced) {
    const bounds = map.getBounds();
    const padded = bounds.pad(-0.15);
    const lastLatLng = L.latLng(lastPlaced.lat, lastPlaced.lng);

    if (!padded.contains(lastLatLng) && !autoPanned) {
      const z = map.getZoom();
      const p = map.project(lastLatLng, z);
      p.y += 80;
      map.panTo(map.unproject(p, z), { animate: true });
      autoPanned = true;
    }
  }

  // ======================
  // ãƒ¡ãƒ¢ã‚¤ãƒ™ãƒ³ãƒˆ
  // ======================
  if (isMinuteMode && isPlaying) {
    currentEvents.forEach(e => {
      if (index >= e.bucketIndex && e.state === 'hidden') {
        e.state = 'active';
        popupQueue.push({
          latlng: e.latlng,
          content: e.content
        });
      }
    });
  }

  currentEvents.forEach(e => {
    if (e.state === 'hidden') return;

    const icon = createMemoIcon(e.icon);
    const marker = L.marker(e.latlng, {
      icon: icon || L.divIcon({
        className: 'eventIcon',
        html: 'ğŸ’¬',
        iconSize: [18, 18],
        iconAnchor: [9, 9]
      }),
      interactive: true,
      zIndexOffset: 1000
    }).addTo(map);

    marker.on('click', () => {
      showEventPopup(e.latlng, e.content, 0);
    });

    eventMarkers.push(marker);
  });

  if (isMinuteMode && isPlaying && popupQueue.length) {
    pumpPopupQueue();
  }

  render._prevIndex = index;
}


  function render(index) {
    clearLayers(footprintMarkers);
    clearLayers(eventMarkers);

    const unit = 'minute';
    const isMinuteMode = (unit === 'minute' && selectedLogId);
    const isPlayback = isMinuteMode && isPlaying;

    const log = logs.find(l => l.id === selectedLogId);
    if (!log || !timeBuckets[index]) return;

    // ======================
    // è¡¨ç¤ºæ™‚åˆ»ï¼ˆåˆ†ä¸¸ã‚æ¸ˆã¿ï¼‰
    // ======================
    const currLabelMs = new Date(timeBuckets[index][0]).getTime();

    const prevIndex =
      (typeof render._prevIndex === 'number') ? render._prevIndex : index;

    const prevLabelMs =
      timeBuckets[prevIndex]
        ? new Date(timeBuckets[prevIndex][0]).getTime()
        : currLabelMs;

    // â˜… å‰å›ã‚³ãƒã¨ã®å·®åˆ†ï¼ˆåˆ†ï¼‰
    const deltaMin = Math.max(
      0,
      Math.round((currLabelMs - prevLabelMs) / 60000)
    );

    // ======================
    // çµŒéæ™‚é–“ï¼ˆ0 â†’ index ã‚’æ¯å›å†è¨ˆç®—ï¼‰
    // ======================
    let elapsedMin = 0;
    for (let i = 1; i <= index; i++) {
      const a = new Date(timeBuckets[i - 1][0]).getTime();
      const b = new Date(timeBuckets[i][0]).getTime();
      elapsedMin += Math.max(0, Math.round((b - a) / 60000));
    }

    // ======================
    // cutoffMs
    // ======================
    let cutoffMs = currLabelMs;
    if (timeBuckets[index + 1]) {
      cutoffMs = new Date(timeBuckets[index + 1][0]).getTime() - 1;
    } else {
      cutoffMs = currLabelMs + 60 * 1000 - 1;
    }

    // ======================
    // è¶³è·¡æç”»
    // ======================
    const zoom = map.getZoom();
    const isRouteScale = zoom >= 14;
    const FOOTPRINT_INTERVAL = 60 * 1000;
    const THIN_BY_DISTANCE = areaRadiusByZoom(zoom);

    const allVisiblePoints = log.points.filter(p => {
      return new Date(p.time).getTime() <= cutoffMs;
    });

    const placed = [];
    let lastPlacedTime = null;
    let lastPlacedLatLng = null;

    allVisiblePoints.forEach(p => {
      const t = new Date(p.time).getTime();

      if (isRouteScale) {
        if (lastPlacedTime && t - lastPlacedTime < FOOTPRINT_INTERVAL) return;
        lastPlacedTime = t;
      }

      const latlng = { lat: p.lat, lng: p.lng };

      if (lastPlacedLatLng) {
        const d = distance(lastPlacedLatLng, latlng);
        if (!isRouteScale && d < THIN_BY_DISTANCE) return;
        if (isRouteScale && d < 8) return;
      }

      lastPlacedLatLng = latlng;
      placed.push(latlng);
    });

    const baseIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa(footprintSvg),
      iconSize: [18, 18],
      iconAnchor: [9, 9]
    });

    placed.forEach((p, idx) => {
      let opacity = 1.0;
      if (isPlayback) {
        const d = placed.length - 1 - idx;
        if (d === 0) opacity = 1.0;
        else if (d === 1) opacity = 0.65;
        else if (d === 2) opacity = 0.4;
        else opacity = 0.25;
      }

      footprintMarkers.push(
        L.marker([p.lat, p.lng], {
          icon: baseIcon,
          interactive: false,
          opacity
        }).addTo(map)
      );
    });

    // ======================
    // ãƒ©ãƒ™ãƒ«æ›´æ–°
    // ======================
    label.textContent = formatLabel(timeBuckets[index][0], unit);

    // ======================
    // è·é›¢è¨ˆç®—
    // ======================
    let dist = 0;
    let last = log.points[0];

    for (let i = 1; i < log.points.length; i++) {
      const p = log.points[i];
      const t = new Date(p.time).getTime();
      if (t > cutoffMs) break;
      dist += distance(last, p);
      last = p;
    }

    const km = (dist / 1000).toFixed(2);

    // ======================
    // çµŒéæ™‚é–“è¡¨ç¤ºï¼ˆâ˜…2æ®µéšå¼·èª¿ï¼‰
    // ======================
    const timeText = formatElapsedTime(elapsedMin);

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    progressLabel.style.transition = 'none';
    progressLabel.style.fontWeight = '400';
    progressLabel.style.transform = 'scale(1)';
    progressLabel.style.opacity = '0.75';

    // â˜… 5åˆ†ä»¥ä¸Šï¼šå¼±å¼·èª¿
    if (deltaMin >= 5) {
      progressLabel.style.fontWeight = '600';
      progressLabel.style.opacity = '0.9';
      progressLabel.style.transform = 'scale(1.08)';
      progressLabel.style.transition =
        'transform 0.18s ease-out, opacity 0.25s ease-out';
    }

    // â˜… 30åˆ†ä»¥ä¸Šï¼šå¼·å¼·èª¿
    if (deltaMin >= 30) {
      progressLabel.style.fontWeight = '700';
      progressLabel.style.opacity = '1.0';
      progressLabel.style.transform = 'scale(1.18)';
    }

    // æˆ»ã—
    if (deltaMin >= 5) {
      requestAnimationFrame(() => {
        setTimeout(() => {
          progressLabel.style.transform = 'scale(1)';
          progressLabel.style.opacity = '0.8';
          progressLabel.style.fontWeight = '400';
        }, 220);
      });
    }

    progressLabel.textContent =
      `ï½œï¼‹${timeText} ï½œ ${km}km`;

    // ======================
    // è‡ªå‹•ãƒ‘ãƒ³
    // ======================
    const lastPlaced = placed.length ? placed[placed.length - 1] : null;
    if (lastPlaced) {
      const bounds = map.getBounds();
      const padded = bounds.pad(-0.15);
      const lastLatLng = L.latLng(lastPlaced.lat, lastPlaced.lng);

      if (!padded.contains(lastLatLng) && !autoPanned) {
        const z = map.getZoom();
        const p = map.project(lastLatLng, z);
        p.y += 80;
        map.panTo(map.unproject(p, z), { animate: true });
        autoPanned = true;
      }
    }

    // ======================
    // ãƒ¡ãƒ¢ã‚¤ãƒ™ãƒ³ãƒˆ
    // ======================
    if (isMinuteMode && isPlaying) {
      currentEvents.forEach(e => {
        if (index >= e.bucketIndex && e.state === 'hidden') {
          e.state = 'active';
          popupQueue.push({
            latlng: e.latlng,
            content: e.content
          });
        }
      });
    }

    currentEvents.forEach(e => {
      if (e.state === 'hidden') return;

      const icon = createMemoIcon(e.icon);
      const marker = L.marker(e.latlng, {
        icon: icon || L.divIcon({
          className: 'eventIcon',
          html: 'ğŸ’¬',
          iconSize: [18, 18],
          iconAnchor: [9, 9]
        }),
        interactive: true,
        zIndexOffset: 1000
      }).addTo(map);

      marker.on('click', () => {
        showEventPopup(e.latlng, e.content, 0);
      });

      eventMarkers.push(marker);
    });

    if (isMinuteMode && isPlaying && popupQueue.length) {
      pumpPopupQueue();
    }

    render._prevIndex = index;
  }

  function buildLogSelect() {
    dateSelect.innerHTML = '<option value="">æ•£æ­©ã‚’é¸ã¶</option>';
    logs.forEach(l => {
      const d = new Date(l.startIso);
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mi = String(d.getMinutes()).padStart(2,'0');
      const note = (l.note || "").trim();
      const title = note ? note : "ï¼ˆãƒ¡ãƒ¢ãªã—ï¼‰";
      const opt = document.createElement('option');
      opt.value = l.id;
      opt.textContent = `${mm}-${dd} ${hh}:${mi}  ${title}`;
      dateSelect.appendChild(opt);
    });
    if (selectedLogId) dateSelect.value = selectedLogId;
  }

  function jumpToSelectedLogStart() {
    const log = logs.find(l => l.id === selectedLogId);
    if (!log) return;
    map.setView(log.firstLatLng, map.getZoom(), { animate: true });
  }

  function updatePlayButtonsState() {
    if (isLoading) {
      playBtn.disabled = true;
      stopBtn.disabled = true;
      return;
    }
    const canPlay = !!selectedLogId;
    playBtn.disabled = !canPlay;
    stopBtn.disabled = !canPlay;
    if (!canPlay) stopPlayback();
  }

  async function rebuild() {
    stopPlayback();
    autoPanned = false;
    popupQueue = [];
    pumpingQueue = false;

    buildLogSelect();
    updatePlayButtonsState();

    const unit = 'minute';
    let targetPoints = [];

    if (unit === 'minute') {
      if (selectedLogId) {
        const log = logs.find(l => l.id === selectedLogId);
        if (log) {
          targetPoints = log.points;
          timeIcon.textContent = "";

          const allMemos = await loadMemosTemporary();

          const startMs = new Date(log.points[0].time).getTime();
          const endMs   = new Date(log.points[log.points.length - 1].time).getTime();

          // â˜… ä¿®æ­£â‘ ï¼špoint + memo ã® minute ã‚’ union
          const bucketKeySet = new Set();

          log.points.forEach(p => {
            bucketKeySet.add(makeTimeKey(p.time, 'minute'));
          });

          allMemos.forEach(m => {
            const t = new Date(m.time).getTime();
            if (t >= startMs && t <= endMs) {
              bucketKeySet.add(makeTimeKey(m.time, 'minute'));
            }
          });

          const timeBucketKeys = Array.from(bucketKeySet).sort();
          timeBuckets = timeBucketKeys.map(k => [k, []]);

          const bucketIndexMap = new Map();
          timeBucketKeys.forEach((k, i) => bucketIndexMap.set(k, i));

          // point ã‚’ bucket ã«è©°ã‚ã‚‹
          log.points.forEach(p => {
            const k = makeTimeKey(p.time, 'minute');
            const idx = bucketIndexMap.get(k);
            timeBuckets[idx][1].push(p);
          });

          // â˜… ä¿®æ­£â‘¡ï¼šmemo ã¯ memo.time ã‚’ 1ã‚³ãƒã¨ã—ã¦æ‰±ã†
          currentEvents = allMemos
            .filter(m => {
              const t = new Date(m.time).getTime();
              return t >= startMs && t <= endMs;
            })
            .map((m, idx) => {
              const nearIdx = findNearestPointIndexByTime(log.points, m.time);
              const p = log.points[nearIdx] || log.points[0];

              const bKey = makeTimeKey(m.time, 'minute');
              const bIdx = bucketIndexMap.get(bKey);

              return {
                id: `memo_${idx}_${m.time}`,
                latlng: [p.lat, p.lng],
                content: m.text || '',
                icon: m.icon || null,
                bucketIndex: bIdx,
                state: 'hidden'
              };
            });
        }
      } else {
        timeIcon.textContent = "";
        currentEvents = [];
      }
    } else {
      targetPoints = allPoints;
      timeIcon.textContent = "";
      currentEvents = [];
      timeBuckets = buildBuckets(unit, targetPoints);
    }

    if (!timeBuckets || !timeBuckets.length) {
      timeBuckets = buildBuckets(unit, targetPoints);
    }

    if (!timeBuckets.length) {
      slider.disabled = true;
      slider.min = 0;
      slider.max = 0;
      slider.value = 0;
      label.textContent = 'ãƒ­ã‚°ãªã—';
      clearLayers(footprintMarkers);
      clearLayers(eventMarkers);
      return;
    }

    slider.min = 0;
    slider.max = timeBuckets.length - 1;
    slider.disabled = false;

    if (unit === 'minute' && selectedLogId) slider.value = String(slider.max);
    else slider.value = "0";

    render(Number(slider.value));
  }

  async function loadFromGAS() {

    isLoading = true;
    playBtn.disabled = true;
    stopBtn.disabled = true;

    const res = await fetch(GAS_URL);
    const files = await res.json();

    allPoints = [];
    logs = [];

    files.forEach((f, idx) => {
      const pts = parseGPX(f.content);
      if (!pts.length) return;

      pts.sort((a, b) => new Date(a.time) - new Date(b.time));
      allPoints.push(...pts);

      logs.push({
        id: `log_${idx}`,
        startIso: pts[0].time,
        points: pts,
        firstLatLng: [pts[0].lat, pts[0].lng],
        note: f.note || ""
      });
    });

    logs.sort((a, b) => new Date(b.startIso) - new Date(a.startIso));
    status.textContent = `${files.length}ãƒ•ã‚¡ã‚¤ãƒ« / ${allPoints.length}ç‚¹`;
    dateSelect.disabled = false;

    await rebuild();

    isLoading = false;
    updatePlayButtonsState(); 
  }

  function parseGPX(text) {
    const pts = [];
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const trkpts = xml.getElementsByTagName("trkpt");
    for (let i = 0; i < trkpts.length; i++) {
      const lat = parseFloat(trkpts[i].getAttribute("lat"));
      const lng = parseFloat(trkpts[i].getAttribute("lon"));
      const timeEl = trkpts[i].getElementsByTagName("time")[0];
      if (timeEl) pts.push({ lat, lng, time: timeEl.textContent });
    }
    return pts;
  }

  slider.addEventListener('input', () => {
    stopPlayback();
    autoPanned = false;
    popupQueue = [];
    pumpingQueue = false;
    render(Number(slider.value));
  });

  dateSelect.addEventListener('change', async () => {
    stopPlayback();

      // â˜… ã“ã“ã§ä¸€æ—¦ã‚¯ãƒªã‚¢
    clearLayers(footprintMarkers);
    clearLayers(eventMarkers);
    label.textContent = 'èª­ã¿è¾¼ã¿ä¸­â€¦';
    progressLabel.textContent = '';
    timeIcon.textContent = '';

    isLoading = true;
    playBtn.disabled = true;
    stopBtn.disabled = true;

    selectedLogId = dateSelect.value;
    if (selectedLogId) jumpToSelectedLogStart();
    await rebuild();
    isLoading = false;
    updatePlayButtonsState();
  });

  map.on('zoomend', () => {
    if (!slider.disabled) render(Number(slider.value));
  });

  playBtn.addEventListener('click', () => {
    restartPlaybackFromBeginning();
  });

  stopBtn.addEventListener('click', () => {
    if (isPlaying) {
      stopBtn.textContent = "å†é–‹";
      stopPlayback();
    } else {
      stopBtn.textContent = "åœæ­¢";
      startPlayback();
    }
  });

  loadFromGAS();
</script>

</body>
</html>
