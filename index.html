<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Fog Map – Organic Walks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #map { height: 88%; }
    #ui {
      height: 12%;
      padding: 12px 16px;
      background: #1a1a1a;
      color: #ccc;
      box-sizing: border-box;
    }
    #monthLabel {
      font-size: 14px;
      margin-top: 4px;
    }
    input[type=range] { width: 100%; }
  </style>
</head>
<body>

<div id="map"></div>

<div id="ui">
  <input type="range" min="1" max="12" value="6" id="slider">
  <div id="monthLabel">6月</div>
</div>

<script>
  // ===== 自宅（必ず通る点）
  const HOME_LAT = 35.721625;
  const HOME_LNG = 140.155500;

  const map = L.map('map', { zoomControl: false })
    .setView([HOME_LAT, HOME_LNG], 15);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap'
  }).addTo(map);

  const GRID_LAT = 0.00012;
  const GRID_LNG = 0.00035;

  function gridKey(lat, lng) {
    return `${Math.floor(lat / GRID_LAT)}_${Math.floor(lng / GRID_LNG)}`;
  }

  function gridBounds(key) {
    const [x, y] = key.split('_').map(Number);
    return [
      [x * GRID_LAT, y * GRID_LNG],
      [(x + 1) * GRID_LAT, (y + 1) * GRID_LNG]
    ];
  }

  // ===== 基本半径
  const BASE_RX = 0.0022;
  const BASE_RY = 0.0017;

  // 月ごとの「主方向」をランダムに生成（かぶりOK）
  const monthAngles = Array.from({ length: 13 }, () =>
    Math.random() * Math.PI * 2
  );

  const monthData = {};
  for (let m = 1; m <= 12; m++) {
    monthData[m] = makeOrganicLoop(m);
  }

  function makeOrganicLoop(month) {
    const pts = [];
    const steps = 36;

    const rx = BASE_RX * (0.9 + Math.random() * 0.3);
    const ry = BASE_RY * (0.9 + Math.random() * 0.3);

    const rotation = monthAngles[month];

    // 歩行ノイズ（累積）
    let noiseLat = 0;
    let noiseLng = 0;

    const raw = [];

    for (let i = 0; i <= steps; i++) {
      const t = (Math.PI * 2 * i) / steps;

      // 基本円
      let x = Math.cos(t) * rx;
      let y = Math.sin(t) * ry;

      // ランダムウォーク的ノイズ
      noiseLat += (Math.random() - 0.5) * 0.00004;
      noiseLng += (Math.random() - 0.5) * 0.00004;

      x += noiseLat;
      y += noiseLng;

      // 回転
      const lat =
        x * Math.cos(rotation) - y * Math.sin(rotation);
      const lng =
        x * Math.sin(rotation) + y * Math.cos(rotation);

      raw.push([lat, lng]);
    }

    // 円周上の始点を自宅に合わせる
    const offsetLat = HOME_LAT - raw[0][0];
    const offsetLng = HOME_LNG - raw[0][1];

    raw.forEach(([lat, lng]) => {
      pts.push([
        lat + offsetLat,
        lng + offsetLng
      ]);
    });

    return pts;
  }

  let fogRects = [];
  let clearRects = [];

  function clearAll() {
    fogRects.forEach(r => map.removeLayer(r));
    clearRects.forEach(r => map.removeLayer(r));
    fogRects = [];
    clearRects = [];
  }

  function drawFog() {
    const b = map.getBounds();
    for (
      let x = Math.floor(b.getSouth() / GRID_LAT);
      x <= Math.floor(b.getNorth() / GRID_LAT);
      x++
    ) {
      for (
        let y = Math.floor(b.getWest() / GRID_LNG);
        y <= Math.floor(b.getEast() / GRID_LNG);
        y++
      ) {
        fogRects.push(
          L.rectangle(
            [[x * GRID_LAT, y * GRID_LNG],
             [(x + 1) * GRID_LAT, (y + 1) * GRID_LNG]],
            {
              color: null,
              fillColor: '#0e0e11',
              fillOpacity: 0.45,
              weight: 0
            }
          ).addTo(map)
        );
      }
    }
  }

  function drawCleared(month) {
    const months = [month - 1, month, month + 1];

    months.forEach(m => {
      if (!monthData[m]) return;

      const countMap = new Map();
      monthData[m].forEach(([lat, lng]) => {
        const k = gridKey(lat, lng);
        countMap.set(k, (countMap.get(k) || 0) + 1);
      });

      countMap.forEach((count, k) => {
        clearRects.push(
          L.rectangle(gridBounds(k), {
            color: null,
            fillColor: '#ffffff',
            fillOpacity: m === month ? 0.35 : 0.15,
            weight: 0
          }).addTo(map)
        );
      });
    });
  }

  function render(month) {
    clearAll();
    drawFog();
    drawCleared(month);
  }

  const slider = document.getElementById('slider');
  const label = document.getElementById('monthLabel');

  slider.addEventListener('input', () => {
    const m = Number(slider.value);
    label.textContent = `${m}月`;
    render(m);
  });

  render(6);
</script>

</body>
</html>
