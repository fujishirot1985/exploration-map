<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Exploration Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #map { height: 80%; }
    #ui {
      height: 20%;
      padding: 10px 14px;
      background: #1a1a1a;
      color: #ddd;
      box-sizing: border-box;
    }
    .row { margin-bottom: 8px; }
    select, input[type="range"] {
      width: 100%;
      padding: 10px;
      background: #111;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 8px;
      font-size: 14px;
    }
    input[type="range"] {
      width: 96%;
      margin: 0 auto;
      display: block;
      height: 28px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 28px; height: 28px;
      border-radius: 50%;
      background: #fff; border: none;
    }
    #dateLabel {
      font-size: 14px; color: #fff; font-weight: bold;
      margin-top: 6px; display: block;
    }
    #status { font-size: 12px; color: #888; }
  </style>
</head>
<body>

<div id="map"></div>

<div id="ui">
  <div class="row">
    <select id="unitSelect">
      <option value="minute">åˆ†ï¼ˆ1åˆ†ï¼‰</option>
      <option value="hour">æ™‚é–“</option>
      <option value="day">æ—¥</option>
      <option value="day_sum">æ—¥ï¼ˆç´¯è¨ˆï¼‰</option>
      <option value="month">æœˆ</option>
      <option value="month_sum">æœˆï¼ˆç´¯è¨ˆï¼‰</option>
    </select>
  </div>

  <div class="row">
    <select id="dateSelect" disabled>
      <option value="">æ—¥ä»˜ã‚’é¸æŠ</option>
    </select>
  </div>

  <div class="row">
    <input type="range" id="timeSlider" min="0" max="0" value="0" disabled />
    <span id="dateLabel">èª­ã¿è¾¼ã¿ä¸­â€¦</span>
  </div>

  <div id="status">ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰ãƒ­ã‚°ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™</div>
</div>

<script>
  const GAS_URL = "https://script.google.com/macros/s/AKfycbxBS-OE16Ny3fCVxkm01DNk1v-D3eBfRvly00A3CSoZWBy3viwZKIiDz4ZXJVXJKDlx/exec";

  const map = L.map('map', { preferCanvas: true })
    .setView([35.7216, 140.1555], 15);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap'
  }).addTo(map);

  let allPoints = [];
  let timeBuckets = [];
  let footprintMarkers = [];
  let selectedDate = null;

  const slider = document.getElementById('timeSlider');
  const label  = document.getElementById('dateLabel');
  const status = document.getElementById('status');
  const unitSelect = document.getElementById('unitSelect');
  const dateSelect = document.getElementById('dateSelect');

  function clearLayers(arr) {
    arr.forEach(l => map.removeLayer(l));
    arr.length = 0;
  }

  function localDateString(iso) {
    const d = new Date(iso);
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }

  function makeTimeKey(iso, unit) {
    const d = new Date(iso);
    if (unit === 'minute') d.setSeconds(0, 0);
    if (unit === 'hour')   d.setMinutes(0, 0, 0);
    if (unit === 'day' || unit === 'day_sum') d.setHours(0, 0, 0, 0);
    if (unit === 'month' || unit === 'month_sum') {
      d.setDate(1); d.setHours(0, 0, 0, 0);
    }
    return d.toISOString();
  }

  function buildBuckets(unit, points = allPoints) {
    const mapBuckets = new Map();
    points.forEach(p => {
      const key = makeTimeKey(p.time, unit);
      if (!mapBuckets.has(key)) mapBuckets.set(key, []);
      mapBuckets.get(key).push(p);
    });
    return Array.from(mapBuckets.entries()).sort((a, b) => a[0].localeCompare(b[0]));
  }

  /* ğŸ¾ è‚‰çƒSVG */
  const footprintSvg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <circle cx="6" cy="7" r="2" fill="#444"/>
    <circle cx="10" cy="5" r="2" fill="#444"/>
    <circle cx="14" cy="5" r="2" fill="#444"/>
    <circle cx="18" cy="7" r="2" fill="#444"/>
    <ellipse cx="12" cy="14" rx="5" ry="4" fill="#444"/>
</svg>
`;

  function colorFromDayKey(dayKey) {
    let hash = 0;
    for (let i = 0; i < dayKey.length; i++) {
      hash = (hash << 5) - hash + dayKey.charCodeAt(i);
      hash |= 0;
    }
    const hue = Math.abs(hash) % 360;
    return `hsl(${hue}, 40%, 45%)`;
  }

  function distance(a, b) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const s =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) *
      Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  // â˜… ç¸®å°ºã”ã¨ã®ã‚¨ãƒªã‚¢åŠå¾„
  function areaRadiusByZoom(zoom) {
    if (zoom >= 14) return 400;   // è¿‘ã„
    if (zoom >= 13) return 500; 
    if (zoom >= 12) return 700;   // å°‘ã—å¼•ã
    if (zoom >= 11) return 1000;   // å°‘ã—å¼•ã
    if (zoom >= 10) return 1400;   // å°‘ã—å¼•ã
    if (zoom >= 9) return 1900;   // å°‘ã—å¼•ã
    if (zoom >= 8) return 2500;   // å°‘ã—å¼•ã
    return 3200;                 // ã ã„ã¶å¼•ã
  }

  function render(index) {
    clearLayers(footprintMarkers);

    const unit = unitSelect.value;
    const isCumulative =
      unit === 'minute' ||
      unit === 'hour' ||
      unit === 'day_sum' ||
      unit === 'month_sum';

    const visible = isCumulative
      ? timeBuckets.slice(0, index + 1)
      : [timeBuckets[index]];

    const zoom = map.getZoom();
    const isRouteScale = zoom >= 14;

    const FOOTPRINT_INTERVAL = 60 * 1000;
    const AREA_RADIUS = areaRadiusByZoom(zoom);

    let lastTime = null;

    visible.forEach(([dayKey, pts]) => {
      const sorted = pts.slice().sort(
        (a, b) => new Date(a.time) - new Date(b.time)
      );

      const color =
        unit === 'day_sum'
          ? colorFromDayKey(dayKey)
          : '#444';

      const icon = L.icon({
        iconUrl:
          'data:image/svg+xml;base64,' +
          btoa(footprintSvg.replace(/fill="#444"/g, `fill="${color}"`)),
        iconSize: [18, 18],
        iconAnchor: [9, 9]
      });

      if (isRouteScale) {
        // é“ç¨‹ãƒ¢ãƒ¼ãƒ‰
        sorted.forEach(p => {
          const t = new Date(p.time).getTime();
          if (!lastTime || t - lastTime >= FOOTPRINT_INTERVAL) {
            lastTime = t;
            footprintMarkers.push(
              L.marker([p.lat, p.lng], { icon, interactive:false }).addTo(map)
            );
          }
        });
      } else {
        // ã‚¨ãƒªã‚¢ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¤‡æ•°ï¼‰
        const areas = [];
        sorted.forEach(p => {
          let placed = false;
          for (const a of areas) {
            if (distance(a, p) <= AREA_RADIUS) {
              a.lat = (a.lat * a.count + p.lat) / (a.count + 1);
              a.lng = (a.lng * a.count + p.lng) / (a.count + 1);
              a.count++;
              placed = true;
              break;
            }
          }
          if (!placed) areas.push({ lat:p.lat, lng:p.lng, count:1 });
        });

        areas.forEach(a => {
          footprintMarkers.push(
            L.marker([a.lat, a.lng], { icon, interactive:false }).addTo(map)
          );
        });
      }
    });

    label.textContent = new Date(timeBuckets[index][0]).toLocaleString();
  }

  function getAvailableDates() {
    const set = new Set();
    allPoints.forEach(p => set.add(localDateString(p.time)));
    return Array.from(set).sort();
  }

  function buildDateSelect() {
    dateSelect.innerHTML = '<option value="">æ—¥ä»˜ã‚’é¸æŠ</option>';
    getAvailableDates().forEach(d => {
      const opt = document.createElement('option');
      opt.value = d;
      opt.textContent = d;
      dateSelect.appendChild(opt);
    });
  }

  function rebuild() {
    const unit = unitSelect.value;
    const needsDate = (unit === 'minute' || unit === 'hour');
    dateSelect.disabled = !needsDate;

    let targetPoints = allPoints;
    if (needsDate && selectedDate) {
      targetPoints = allPoints.filter(p => localDateString(p.time) === selectedDate);
    }

    timeBuckets = buildBuckets(unit, targetPoints);

    if (!timeBuckets.length) {
      slider.disabled = true;
      label.textContent = 'ãƒ­ã‚°ãªã—';
      return;
    }

    slider.min = 0;
    slider.max = timeBuckets.length - 1;
    slider.value = slider.min;
    slider.disabled = false;

    render(slider.value);
  }

  async function loadFromGAS() {
    const res = await fetch(GAS_URL);
    const files = await res.json();
    allPoints = [];
    files.forEach(f => allPoints.push(...parseGPX(f.content)));
    status.textContent = `${files.length}ãƒ•ã‚¡ã‚¤ãƒ« / ${allPoints.length}ç‚¹`;
    buildDateSelect();
    rebuild();
  }

  function parseGPX(text) {
    const pts = [];
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const trkpts = xml.getElementsByTagName("trkpt");
    for (let i = 0; i < trkpts.length; i++) {
      const lat = parseFloat(trkpts[i].getAttribute("lat"));
      const lng = parseFloat(trkpts[i].getAttribute("lon"));
      const timeEl = trkpts[i].getElementsByTagName("time")[0];
      if (timeEl) pts.push({ lat, lng, time: timeEl.textContent });
    }
    return pts;
  }

  slider.addEventListener('input', () => render(Number(slider.value)));
  unitSelect.addEventListener('change', rebuild);
  dateSelect.addEventListener('change', () => {
    selectedDate = dateSelect.value;
    rebuild();
  });

  map.on('zoomend', () => {
    if (!slider.disabled) render(Number(slider.value));
  });

  loadFromGAS();
</script>

</body>
</html>
