<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Exploration Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { margin:0; height:100%; background:#111; font-family:-apple-system,BlinkMacSystemFont,sans-serif; }
    #map { height:80%; }
    #ui { height:20%; padding:10px 14px; background:#1a1a1a; color:#ddd; box-sizing:border-box; }
    .row { margin-bottom:8px; }
    select, input[type="range"], button {
      width:100%; padding:10px; background:#111; color:#ddd; border:1px solid #333;
      border-radius:8px; font-size:14px; box-sizing:border-box;
    }
    input[type="range"] { width:96%; margin:0 auto; display:block; height:28px; }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance:none; width:28px; height:28px; border-radius:50%; background:#fff; border:none;
    }
    #dateLabel { font-size:14px; color:#fff; font-weight:bold; }
    #timeIcon { margin-right:6px; font-size:16px; }
    #status { font-size:12px; color:#888; }
    .row.flex { display:flex; gap:8px; align-items:center; overflow:hidden; }
    .row.flex > * { min-width:0; }
    button#playBtn { flex:0 0 120px; }
    button#stopBtn { flex:0 0 80px; opacity:0.95; }
    select#dateSelect { text-overflow:ellipsis; overflow:hidden; white-space:nowrap; }
    .timeRow { display:flex; align-items:center; gap:6px; }

    .eventIcon {
      font-size:20px; line-height:20px; transform:translateY(-2px);
      filter:drop-shadow(0 1px 2px rgba(0,0,0,0.65));
      opacity:0.95; user-select:none;
    }
    .evtPopup {
      font-size:12px; color:#eee; background:rgba(20,20,20,0.92);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px; padding:8px 10px; max-width:220px;
      animation:fadeIn 0.22s ease-out forwards;
    }
    @keyframes fadeIn { from { opacity:0; transform:translateY(4px);} to { opacity:1; transform:translateY(0);} }
    .leaflet-popup-content-wrapper { background:transparent; box-shadow:none; }
    .leaflet-popup-tip { background:rgba(20,20,20,0.92); }
  </style>
</head>
<body>

<div id="map"></div>

<div id="ui">
  <div class="row">
    <select id="dateSelect" disabled>
      <option value="">Êï£Ê≠©„ÇíÈÅ∏„Å∂</option>
    </select>
  </div>

  <div class="row flex">
    <button id="playBtn" disabled>Êï£Ê≠©„Çπ„Çø„Éº„Éà</button>
    <button id="stopBtn" disabled>ÂÅúÊ≠¢</button>
  </div>

  <div class="row timeRow">
    <span id="timeIcon"></span>
    <span id="dateLabel">Ë™≠„ÅøËæº„Åø‰∏≠‚Ä¶</span>
    <span id="progressLabel" style="font-size:12px; color:#bbb; margin-left:8px;"></span>
  </div>

  <div class="row">
    <input type="range" id="timeSlider" min="0" max="0" value="0" disabled />
  </div>

  <div id="status">„ÇØ„É©„Ç¶„Éâ„Åã„Çâ„É≠„Ç∞„ÇíË™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô</div>
</div>

<script>
  const GAS_URL = "https://script.google.com/macros/s/AKfycbx36tsy3sptr2-gaJnHr__Gq6VWxQ6cunpRMvNISNKjS-2NHorz0qYbKJJV8P0VDdBC/exec";
  const LOG_ID_FOR_MEMOS = "log_test"; // Êö´ÂÆö

  const map = L.map('map', { preferCanvas: true }).setView([35.7216, 140.1555], 15);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' }).addTo(map);

  let allPoints = [];
  let timeBuckets = [];
  let footprintMarkers = [];
  let eventMarkers = [];

  let logs = [];
  let selectedLogId = "";

  let autoPanned = false;

  let playTimer = null;
  let isPlaying = false;

  // „Ç§„Éô„É≥„Éà
  let currentEvents = [];
  let lastAutoPopupAt = 0;

  // Âêå‰∏Äbucket„ÅßË§áÊï∞„É°„É¢„ÇíÈ†Ü„Å´Âá∫„Åô„Åü„ÇÅ„ÅÆÁ∞°Êòì„Ç≠„É•„Éº
  let popupQueue = [];
  let pumpingQueue = false;

  const slider = document.getElementById('timeSlider');
  const label  = document.getElementById('dateLabel');
  const progressLabel = document.getElementById('progressLabel');
  const timeIcon = document.getElementById('timeIcon');
  const status = document.getElementById('status');
  const dateSelect = document.getElementById('dateSelect');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');

  // ===== „É°„É¢Áî®„Ç¢„Ç§„Ç≥„É≥ÂÆöÁæ© =====
  const MEMO_ICON_DEFS = {
    event:  { html: 'üìç', className: 'icon-event' },   // ‰Ωï„Åã„ÅÇ„Å£„Åü
    food:   { html: 'üç¥', className: 'icon-food' },    // È£ü„Åπ„Åü
    notice: { html: 'üí°', className: 'icon-notice' },  // Ê∞ó„Å•„Åç
    rest:   { html: '‚òï', className: 'icon-rest' }   
  };

  function createMemoIcon(iconType) {
    const def = MEMO_ICON_DEFS[iconType];
    if (!def) return null;

    return L.divIcon({
      className: `eventIcon ${def.className}`,
      html: def.html,
      iconSize: [18, 18],
      iconAnchor: [9, 9]
    });
  }

  function clearLayers(arr) {
    arr.forEach(l => map.removeLayer(l));
    arr.length = 0;
  }

  function makeTimeKey(iso, unit) {
    const d = new Date(iso);
    if (unit === 'minute') d.setSeconds(0, 0);
    if (unit === 'hour')   d.setMinutes(0, 0, 0);
    if (unit === 'day' || unit === 'day_sum') d.setHours(0, 0, 0, 0);
    if (unit === 'month' || unit === 'month_sum') { d.setDate(1); d.setHours(0, 0, 0, 0); }
    return d.toISOString();
  }

  function buildBuckets(unit, points = allPoints) {
    const mapBuckets = new Map();
    points.forEach(p => {
      const key = makeTimeKey(p.time, unit);
      if (!mapBuckets.has(key)) mapBuckets.set(key, []);
      mapBuckets.get(key).push(p);
    });
    return Array.from(mapBuckets.entries()).sort((a, b) => a[0].localeCompare(b[0]));
  }

  const footprintSvg =
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">' +
    '<circle cx="6"  cy="7"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="10" cy="5"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="14" cy="5"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="18" cy="7"  r="2.8" fill="rgba(255,255,255,0.8)"/>' +
    '<ellipse cx="12" cy="14" rx="5.8" ry="4.6" fill="rgba(255,255,255,0.8)"/>' +
    '<circle cx="6"  cy="7"  r="2" fill="#444"/>' +
    '<circle cx="10" cy="5"  r="2" fill="#444"/>' +
    '<circle cx="14" cy="5"  r="2" fill="#444"/>' +
    '<circle cx="18" cy="7"  r="2" fill="#444"/>' +
    '<ellipse cx="12" cy="14" rx="5" ry="4" fill="#444"/>' +
  '</svg>';

  function distance(a, b) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLng = toRad(b.lng - a.lng);
    const s =
      Math.sin(dLat/2)**2 +
      Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) *
      Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function areaRadiusByZoom(zoom) {
    if (zoom >= 14) return 400;
    if (zoom >= 13) return 550;
    if (zoom >= 12) return 800;
    if (zoom >= 11) return 1200;
    if (zoom >= 10) return 1600;
    if (zoom >= 9)  return 2200;
    return 3000;
  }

  function timeIconFromHour(h) {
    if (h >= 5 && h < 9)  return "üåÖ";
    if (h >= 9 && h < 16) return "‚òÄÔ∏è";
    if (h >= 16 && h < 19) return "üåÜ";
    return "üåô";
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function showEventPopup(latlng, content, autoCloseMs = 0) {
    const now = Date.now();
    if (autoCloseMs > 0 && now - lastAutoPopupAt < 250) return;
    lastAutoPopupAt = now;

    const popup = L.popup({ closeButton: false, autoClose: true, closeOnClick: true })
      .setLatLng(latlng)
      .setContent(`<div class="evtPopup">${escapeHtml(content)}</div>`)
      .openOn(map);

    if (autoCloseMs > 0) {
      setTimeout(() => {
        try { map.closePopup(popup); } catch(e) {}
      }, autoCloseMs);
    }
  }

  async function loadMemosTemporary() {
    try {
      const url = `${GAS_URL}?type=memos&logId=${encodeURIComponent(LOG_ID_FOR_MEMOS)}`;
      const res = await fetch(url);
      if (!res.ok) return [];
      const memos = await res.json();
      return Array.isArray(memos) ? memos : [];
    } catch (e) {
      return [];
    }
  }

  function findNearestPointIndexByTime(points, isoTime) {
    const target = new Date(isoTime).getTime();
    if (!points.length) return 0;

    let lo = 0;
    let hi = points.length - 1;

    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const t = new Date(points[mid].time).getTime();
      if (t === target) return mid;
      if (t < target) lo = mid + 1;
      else hi = mid - 1;
    }

    if (lo <= 0) return 0;
    if (lo >= points.length) return points.length - 1;

    const tLo = Math.abs(new Date(points[lo].time).getTime() - target);
    const tHi = Math.abs(new Date(points[lo - 1].time).getTime() - target);
    return (tHi <= tLo) ? (lo - 1) : lo;
  }

  function formatLabel(dateIso, unit) {
    const d = new Date(dateIso);
    if (unit === "day" || unit === "day_sum") return d.toLocaleDateString();
    if (unit === "month" || unit === "month_sum") return `${d.getFullYear()}Âπ¥${d.getMonth() + 1}Êúà`;
    return d.toLocaleString();
  }

  function stopPlayback() {
    if (playTimer) { clearInterval(playTimer); playTimer = null; }
    isPlaying = false;
  }

  function startPlayback() {
    const unit = 'minute';
    if (!(unit === 'minute' && selectedLogId)) return;
    if (isPlaying) return;

    isPlaying = true;
    stopBtn.textContent = "ÂÅúÊ≠¢";

    const stepMs = 1800;
    playTimer = setInterval(() => {
      const v = Number(slider.value);
      const max = Number(slider.max);
      if (v >= max) { stopPlayback(); return; }
      autoPanned = false;
      slider.value = String(v + 1);
      render(Number(slider.value));
    }, stepMs);
  }

  function restartPlaybackFromBeginning() {
    stopPlayback();
    slider.value = "0";
    autoPanned = false;
    currentEvents.forEach(e => e.fired = false);
    popupQueue = [];
    pumpingQueue = false;
    render(0);
    startPlayback();
  }

  function pumpPopupQueue() {
    if (pumpingQueue) return;
    pumpingQueue = true;

    const tick = () => {
      if (!popupQueue.length) { pumpingQueue = false; return; }
      const item = popupQueue.shift();
      showEventPopup(item.latlng, item.content, 2200);
      setTimeout(tick, 550);
    };
    tick();
  }

  function render(index) {
    clearLayers(footprintMarkers);
    clearLayers(eventMarkers);

    const unit = 'minute';
    const isMinuteMode = (unit === 'minute' && selectedLogId);
    const isPlayback = isMinuteMode && isPlaying;

    const isCumulative = unit === 'minute' || unit === 'hour' || unit === 'day_sum' || unit === 'month_sum';
    const visible = isCumulative ? timeBuckets.slice(0, index + 1) : [timeBuckets[index]];

    const zoom = map.getZoom();
    const isRouteScale = zoom >= 14;
    const FOOTPRINT_INTERVAL = 60 * 1000;
    const THIN_BY_DISTANCE = areaRadiusByZoom(zoom);

    const allVisiblePoints = [];
    visible.forEach(([_, pts]) => {
      const sorted = pts.slice().sort((a, b) => new Date(a.time) - new Date(b.time));
      sorted.forEach(p => allVisiblePoints.push(p));
    });

    const placed = [];
    let lastPlacedTime = null;
    let lastPlacedLatLng = null;

    allVisiblePoints.forEach(p => {
      const t = new Date(p.time).getTime();
      if (isRouteScale) {
        if (lastPlacedTime && t - lastPlacedTime < FOOTPRINT_INTERVAL) return;
        lastPlacedTime = t;
      }
      const latlng = { lat: p.lat, lng: p.lng };
      if (lastPlacedLatLng) {
        const d = distance(lastPlacedLatLng, latlng);
        if (!isRouteScale && d < THIN_BY_DISTANCE) return;
        if (isRouteScale && d < 8) return;
      }
      lastPlacedLatLng = latlng;
      placed.push(latlng);
    });

    const baseIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa(footprintSvg),
      iconSize: [18, 18],
      iconAnchor: [9, 9]
    });

    placed.forEach((p, idx) => {
      let opacity = 1.0;
      if (isPlayback) {
        const d = placed.length - 1 - idx;
        if (d === 0) opacity = 1.00;
        else if (d === 1) opacity = 0.65;
        else if (d === 2) opacity = 0.40;
        else opacity = 0.25;
      }
      footprintMarkers.push(L.marker([p.lat, p.lng], { icon: baseIcon, interactive: false, opacity }).addTo(map));
    });

    label.textContent = formatLabel(timeBuckets[index][0], unit);

    // ÁµåÈÅéÊÉÖÂ†±
    if (isMinuteMode && selectedLogId) {
      const log = logs.find(l => l.id === selectedLogId);
      if (log && log.points.length > 1 && timeBuckets[index]) {
        const startTime = new Date(log.points[0].time);
        const bucketIso = timeBuckets[index][0];
        const cutoffMs = new Date(bucketIso).getTime();

        let dist = 0;
        let last = log.points[0];
        let currentTimeMs = startTime.getTime();

        for (let i = 1; i < log.points.length; i++) {
          const p = log.points[i];
          const t = new Date(p.time).getTime();
          if (t > cutoffMs) break;
          dist += distance(last, p);
          last = p;
          currentTimeMs = t;
        }

        const elapsedMin = Math.floor((currentTimeMs - startTime.getTime()) / 60000);
        const km = (dist / 1000).toFixed(2);
        progressLabel.textContent = `ÔΩúÔºã${elapsedMin}ÂàÜ ÔΩú ${km}km`;
      } else {
        progressLabel.textContent = '';
      }
    } else {
      progressLabel.textContent = '';
    }

    // Ëá™Âãï„Éë„É≥ÔºàË∂≥Ë∑°Ôºâ
    const lastPlaced = placed.length ? placed[placed.length - 1] : null;
    if (lastPlaced) {
      const bounds = map.getBounds();
      const padded = bounds.pad(-0.15);
      const lastLatLng = L.latLng(lastPlaced.lat, lastPlaced.lng);

      if (!padded.contains(lastLatLng) && !autoPanned) {
        const z = map.getZoom();
        const p = map.project(lastLatLng, z);
        p.y += 80;
        map.panTo(map.unproject(p, z), { animate: true });
        autoPanned = true;
      }
    }

    // ===== „Ç§„Éô„É≥„Éà„Ç¢„Ç§„Ç≥„É≥ÔºàÂ∏∏ÈßêÔºâ=====
    currentEvents.forEach(e => {
      const icon = createMemoIcon(e.icon);

      const marker = L.marker(e.latlng, {
        icon: icon || L.divIcon({
          className: 'eventIcon',
          html: 'üí¨',           // ‚Üê icon Êú™ÊåáÂÆöÊôÇ„ÅØÂæìÊù•ÈÄö„Çä
          iconSize: [18, 18],
          iconAnchor: [9, 9]
        }),
        interactive: true
      }).addTo(map);

      marker.on('click', () => {
        showEventPopup(e.latlng, e.content, 0);
      });

      eventMarkers.push(marker);
    });

    // ===== Ëá™ÂãïÂÜçÁîü‰∏≠ÔºöÂèñ„Çä„Åì„Åº„Åï„Å™„ÅÑÁô∫ÁÅ´Ôºà>= „Å´„Åô„ÇãÔºâ=====
    if (isMinuteMode && isPlaying) {
      currentEvents.forEach(e => {
        if (e.fired) return;

        // ‚òÖ„Äå„Åù„ÅÆbucket„Å´Âà∞ÈÅî or ÈÄöÈÅé„Äç„ÅßÁô∫ÁÅ´ÔºàÂèñ„Çä„Åì„Åº„ÅóÈò≤Ê≠¢Ôºâ
        if (index >= e.bucketIndex) {
          e.fired = true;
          popupQueue.push({ latlng: e.latlng, content: e.content });
        }
      });

      if (popupQueue.length) pumpPopupQueue();
    }
  }

  function buildLogSelect() {
    dateSelect.innerHTML = '<option value="">Êï£Ê≠©„ÇíÈÅ∏„Å∂</option>';
    logs.forEach(l => {
      const d = new Date(l.startIso);
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mi = String(d.getMinutes()).padStart(2,'0');
      const note = (l.note || "").trim();
      const title = note ? note : "Ôºà„É°„É¢„Å™„ÅóÔºâ";
      const opt = document.createElement('option');
      opt.value = l.id;
      opt.textContent = `${yyyy}-${mm}-${dd} ${hh}:${mi}  ${title}`;
      dateSelect.appendChild(opt);
    });
    if (selectedLogId) dateSelect.value = selectedLogId;
  }

  function jumpToSelectedLogStart() {
    const log = logs.find(l => l.id === selectedLogId);
    if (!log) return;
    map.setView(log.firstLatLng, map.getZoom(), { animate: true });
  }

  function updatePlayButtonsState() {
    const canPlay = !!selectedLogId;
    playBtn.disabled = !canPlay;
    stopBtn.disabled = !canPlay;
    if (!canPlay) stopPlayback();
  }

  async function rebuild() {
    stopPlayback();
    autoPanned = false;
    popupQueue = [];
    pumpingQueue = false;

    buildLogSelect();
    updatePlayButtonsState();

    const unit = 'minute';
    let targetPoints = [];

    if (unit === 'minute') {
      if (selectedLogId) {
        const log = logs.find(l => l.id === selectedLogId);
        if (log) {
          targetPoints = log.points;
          timeIcon.textContent = timeIconFromHour(new Date(log.startIso).getHours());

          const allMemos = await loadMemosTemporary();

          // bucketsÔºàminuteÔºâ„ÇíÂÖà„Å´‰Ωú„Çã
          const tmpBuckets = buildBuckets('minute', log.points);
          const bucketIndexMap = new Map();
          tmpBuckets.forEach(([key], i) => bucketIndexMap.set(key, i));

          const startMs = new Date(log.points[0].time).getTime();
          const endMs   = new Date(log.points[log.points.length - 1].time).getTime();

          currentEvents = allMemos
            .filter(m => {
              const t = new Date(m.time).getTime();
              return t >= startMs && t <= endMs;
            })
            .map((m, idx) => {
              const nearIdx = findNearestPointIndexByTime(log.points, m.time);
              const p = log.points[nearIdx] || log.points[0];

              // ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ „Åì„Åì„ÅåÈáçË¶ÅÔºöm.time „Åß„ÅØ„Å™„Åè„ÄåÂê∏ÁùÄ„Åó„ÅüÁÇπ p.time„Äç„Åß bucketIndex „Çí‰Ωú„Çã ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ
              const bKey = makeTimeKey(p.time, 'minute');               // ‚ÜêÂ§âÊõ¥ÁÇπÔºàm.time ‚Üí p.timeÔºâ
              const bIdx = bucketIndexMap.has(bKey) ? bucketIndexMap.get(bKey) : 0;

              return {
                id: `memo_${idx}_${m.time}`,
                latlng: [p.lat, p.lng],       // Ë∂≥Ë∑°„Å´Âê∏ÁùÄ
                content: m.text || '',
                icon: m.icon || null,
                fired: false,
                bucketIndex: bIdx             // bucket index„ÅßÁô∫ÁÅ´
              };
            });

          // bucketsÁ¢∫ÂÆö
          timeBuckets = tmpBuckets;
        }
      } else {
        timeIcon.textContent = "";
        currentEvents = [];
      }
    } else {
      targetPoints = allPoints;
      timeIcon.textContent = "";
      currentEvents = [];
      timeBuckets = buildBuckets(unit, targetPoints);
    }

    if (!timeBuckets || !timeBuckets.length) {
      timeBuckets = buildBuckets(unit, targetPoints);
    }

    if (!timeBuckets.length) {
      slider.disabled = true;
      slider.min = 0;
      slider.max = 0;
      slider.value = 0;
      label.textContent = '„É≠„Ç∞„Å™„Åó';
      clearLayers(footprintMarkers);
      clearLayers(eventMarkers);
      return;
    }

    slider.min = 0;
    slider.max = timeBuckets.length - 1;
    slider.disabled = false;

    if (unit === 'minute' && selectedLogId) slider.value = String(slider.max);
    else slider.value = "0";

    render(Number(slider.value));
  }

  async function loadFromGAS() {
    const res = await fetch(GAS_URL);
    const files = await res.json();

    allPoints = [];
    logs = [];

    files.forEach((f, idx) => {
      const pts = parseGPX(f.content);
      if (!pts.length) return;

      pts.sort((a, b) => new Date(a.time) - new Date(b.time));
      allPoints.push(...pts);

      logs.push({
        id: `log_${idx}`,
        startIso: pts[0].time,
        points: pts,
        firstLatLng: [pts[0].lat, pts[0].lng],
        note: f.note || ""
      });
    });

    logs.sort((a, b) => new Date(a.startIso) - new Date(b.startIso));
    status.textContent = `${files.length}„Éï„Ç°„Ç§„É´ / ${allPoints.length}ÁÇπ`;
    dateSelect.disabled = false;

    await rebuild();
  }

  function parseGPX(text) {
    const pts = [];
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const trkpts = xml.getElementsByTagName("trkpt");
    for (let i = 0; i < trkpts.length; i++) {
      const lat = parseFloat(trkpts[i].getAttribute("lat"));
      const lng = parseFloat(trkpts[i].getAttribute("lon"));
      const timeEl = trkpts[i].getElementsByTagName("time")[0];
      if (timeEl) pts.push({ lat, lng, time: timeEl.textContent });
    }
    return pts;
  }

  slider.addEventListener('input', () => {
    stopPlayback();
    autoPanned = false;
    popupQueue = [];
    pumpingQueue = false;
    render(Number(slider.value));
  });

  dateSelect.addEventListener('change', async () => {
    stopPlayback();
    selectedLogId = dateSelect.value;
    if (selectedLogId) jumpToSelectedLogStart();
    await rebuild();
  });

  map.on('zoomend', () => {
    if (!slider.disabled) render(Number(slider.value));
  });

  playBtn.addEventListener('click', () => {
    restartPlaybackFromBeginning();
  });

  stopBtn.addEventListener('click', () => {
    if (isPlaying) {
      stopBtn.textContent = "ÂÜçÈñã";
      stopPlayback();
    } else {
      stopBtn.textContent = "ÂÅúÊ≠¢";
      startPlayback();
    }
  });

  loadFromGAS();
</script>

</body>
</html>
